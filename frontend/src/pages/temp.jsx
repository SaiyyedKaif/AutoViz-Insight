import React, { useState, useEffect, useMemo, useCallback } from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ScatterChart,
  Scatter,
  CartesianGrid,
  ZAxis,
} from "recharts";

// --- Dataset Schema and Dashboard Specification ---
const DATASET_SCHEMA = {
  dataset: {
    endpoint: "http://127.0.0.1:8000/api/analysis/dataset/11",
    method: "GET",
    columns: [
      { name: "Date", type: "object" },
      { name: "Region", type: "object" },
      { name: "Product", type: "object" },
      { name: "Sales", type: "int64" },
      { name: "Profit", type: "int64" },
      { name: "Quantity", type: "int64" },
      { name: "Discount", type: "int64" },
    ],
  },
};

const DASHBOARD_SPEC = {
  graphs: [
    {
      title: "Total Sales by Region",
      description:
        "Shows the total sales performance for each geographical region, highlighting top-performing areas.",
      graph_type: "bar chart(columns)",
      x_axis: {
        feature: "Region",
        aggregation: "none",
        bin_size: null,
        label: "Region",
      },
      y_axis: {
        feature: "Sales",
        aggregation: "sum",
        label: "Total Sales",
      },
      group_by: null,
      filters: [],
    },
    {
      title: "Total Sales by Product",
      description:
        "Displays the total sales generated by each product, identifying best-selling items.",
      graph_type: "bar chart(columns)",
      x_axis: {
        feature: "Product",
        aggregation: "none",
        bin_size: null,
        label: "Product",
      },
      y_axis: {
        feature: "Sales",
        aggregation: "sum",
        label: "Total Sales",
      },
      group_by: null,
      filters: [],
    },
    {
      title: "Profitability vs. Discount Applied",
      description:
        "Examines the relationship between the discount offered and the resulting profit.",
      graph_type: "scatter chart",
      x_axis: {
        feature: "Discount",
        aggregation: "none",
        label: "Discount (%)",
      },
      y_axis: {
        feature: "Profit",
        aggregation: "none",
        label: "Profit",
      },
      group_by: null,
    },
    {
      title: "Regional Sales Breakdown by Product",
      description:
        "Illustrates the contribution of each product to the total sales within different regions.",
      graph_type: "stacked bar chart",
      x_axis: { feature: "Region", aggregation: "none", label: "Region" },
      y_axis: { feature: "Sales", aggregation: "sum", label: "Total Sales" },
      group_by: "Product",
    },
    {
      title: "Average Profit by Discount Level",
      description:
        "Shows the average profit achieved for different discount ranges.",
      graph_type: "bar chart(columns)",
      x_axis: {
        feature: "Discount",
        aggregation: "none",
        bin_size: 0.1,
        label: "Discount Range",
      },
      y_axis: {
        feature: "Profit",
        aggregation: "avg",
        label: "Average Profit",
      },
      group_by: null,
    },
    {
      title: "Product Performance: Sales, Quantity, and Profit",
      description:
        "Visualizes sales, quantity sold, and total profit for each product.",
      graph_type: "bubble chart",
      x_axis: {
        feature: "Quantity",
        aggregation: "sum",
        label: "Total Quantity Sold",
      },
      y_axis: { feature: "Sales", aggregation: "sum", label: "Total Sales" },
      group_by: "Product",
      additional_params: {
        bubble_size_feature: "Profit",
        bubble_size_aggregation: "sum",
      },
    },
  ],
};

// --- Helpers ---
const parseData = (rawData, schemaColumns) => {
  if (!rawData || !Array.isArray(rawData)) return [];
  return rawData.map((row) => {
    const newRow = { ...row };
    schemaColumns.forEach((col) => {
      if (col.name in newRow) {
        if (col.name === "Date" && typeof newRow[col.name] === "string") {
          newRow[col.name] = new Date(newRow[col.name]);
        }
        if (
          ["int64", "float64"].includes(col.type) &&
          typeof newRow[col.name] !== "number"
        ) {
          newRow[col.name] = parseFloat(newRow[col.name]) || 0;
        }
      }
    });
    return newRow;
  });
};

const aggregate = (data, feature, aggregationType) => {
  if (!data || data.length === 0) return 0;
  const values = data
    .map((d) => d[feature])
    .filter((v) => typeof v === "number" && !isNaN(v));
  if (values.length === 0) return 0;
  switch (aggregationType) {
    case "sum":
      return values.reduce((a, v) => a + v, 0);
    case "count":
      return values.length;
    case "avg":
      return values.reduce((a, v) => a + v, 0) / values.length;
    case "none":
      return values[0];
    default:
      return 0;
  }
};

const COLORS = [
  "#8884d8",
  "#82ca9d",
  "#ffc658",
  "#ff7300",
  "#0088FE",
  "#00C49F",
  "#FFBB28",
  "#FF8042",
  "#AF19FF",
  "#FF19AF",
  "#19FFAF",
];

// Tooltip
const CustomTooltip = ({
  active,
  payload,
  label,
  graphType,
  xLabel,
  yLabel,
  bubbleSizeFeature,
}) => {
  if (active && payload && payload.length) {
    return (
      <div
        style={{
          background: "#fff",
          border: "1px solid #ccc",
          padding: "10px",
          borderRadius: "5px",
        }}
      >
        <p style={{ margin: 0, fontWeight: "bold" }}>
          {xLabel}: {label}
        </p>
        {payload.map((p, i) => (
          <p key={i} style={{ margin: "5px 0", color: p.color }}>
            {p.name}: {p.value}
            {graphType === "bubble chart" &&
              bubbleSizeFeature &&
              p.payload[bubbleSizeFeature] && (
                <> ({bubbleSizeFeature}: {p.payload[bubbleSizeFeature]})</>
              )}
          </p>
        ))}
      </div>
    );
  }
  return null;
};

// --- Chart Renderer ---
const ChartRenderer = ({ graphConfig, rawData, schemaColumns }) => {
  const { title, description, graph_type, x_axis, y_axis, group_by } =
    graphConfig;
  const xFeature = x_axis.feature;
  const yFeature = y_axis.feature;

  const processedData = useMemo(() => {
    if (!rawData || rawData.length === 0) return [];
    let grouped = {};
    rawData.forEach((item) => {
      const xVal = item[xFeature];
      if (!grouped[xVal]) grouped[xVal] = [];
      grouped[xVal].push(item);
    });
    return Object.keys(grouped).map((xVal) => ({
      [xFeature]: xVal,
      [yFeature]: aggregate(grouped[xVal], yFeature, y_axis.aggregation),
    }));
  }, [rawData, xFeature, yFeature, y_axis.aggregation]);

  const renderChart = () => {
    if (!processedData.length) return <p>No data</p>;
    switch (graph_type) {
      case "bar chart(columns)":
        return (
          <BarChart data={processedData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey={xFeature} />
            <YAxis />
            <Tooltip
              content={
                <CustomTooltip
                  xLabel={x_axis.label}
                  yLabel={y_axis.label}
                  graphType="bar"
                />
              }
            />
            <Legend />
            <Bar dataKey={yFeature} fill={COLORS[0]} />
          </BarChart>
        );
      case "scatter chart":
        return (
          <ScatterChart data={rawData}>
            <CartesianGrid />
            <XAxis dataKey={xFeature} />
            <YAxis dataKey={yFeature} />
            <Tooltip
              content={
                <CustomTooltip
                  xLabel={x_axis.label}
                  yLabel={y_axis.label}
                  graphType="scatter"
                />
              }
            />
            <Scatter dataKey={yFeature} fill={COLORS[1]} />
          </ScatterChart>
        );
      case "bubble chart":
        const bubbleSizeFeature =
          graphConfig.additional_params?.bubble_size_feature;
        return (
          <ScatterChart data={rawData}>
            <CartesianGrid />
            <XAxis dataKey={xFeature} />
            <YAxis dataKey={yFeature} />
            <ZAxis dataKey={bubbleSizeFeature} range={[50, 400]} />
            <Tooltip
              content={
                <CustomTooltip
                  xLabel={x_axis.label}
                  yLabel={y_axis.label}
                  graphType="bubble chart"
                  bubbleSizeFeature={bubbleSizeFeature}
                />
              }
            />
            <Scatter dataKey={yFeature} fill={COLORS[2]} />
          </ScatterChart>
        );
      default:
        return <p>Unsupported chart</p>;
    }
  };

  return (
    <div style={{ background: "#fff", padding: "15px", borderRadius: "8px" }}>
      <h3>{title}</h3>
      <p>{description}</p>
      <ResponsiveContainer width="100%" height={300}>
        {renderChart()}
      </ResponsiveContainer>
    </div>
  );
};

// --- Main Dashboard ---
const AutoVizDashboard = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  const endpoint = DATASET_SCHEMA.dataset.endpoint;
  const schemaColumns = DATASET_SCHEMA.dataset.columns;

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch(endpoint);
      const rawData = await res.json();
      setData(parseData(rawData, schemaColumns));
    } catch (err) {
      console.error("Error fetching data", err);
    } finally {
      setLoading(false);
    }
  }, [endpoint, schemaColumns]);

  useEffect(() => {
    fetchData();
    const id = setInterval(fetchData, 60000);
    return () => clearInterval(id);
  }, [fetchData]);

  if (loading) return <p>Loading...</p>;
  if (!data.length) return <p>No data available</p>;

  return (
    <div style={{ padding: "20px", background: "#f5f5f5" }}>
      <h1 style={{ textAlign: "center" }}>Sales Dashboard</h1>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(400px, 1fr))",
          gap: "20px",
        }}
      >
        {DASHBOARD_SPEC.graphs.map((g, i) => (
          <ChartRenderer
            key={i}
            graphConfig={g}
            rawData={data}
            schemaColumns={schemaColumns}
          />
        ))}
      </div>
    </div>
  );
};

export default AutoVizDashboard;
